
led.elf:     file format elf32-littlenios2
led.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010020

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00010020 paddr 0x00010020 align 2**12
         filesz 0x00000630 memsz 0x00000630 flags r-x
    LOAD off    0x00001650 vaddr 0x00010650 paddr 0x00010740 align 2**12
         filesz 0x000000f0 memsz 0x000000f0 flags rw-
    LOAD off    0x00001830 vaddr 0x00010830 paddr 0x00010830 align 2**12
         filesz 0x00000000 memsz 0x00000004 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00010000  00010000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00000624  00010020  00010020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000000c  00010644  00010644  00001644  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       000000f0  00010650  00010740  00001650  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          00000004  00010830  00010830  00001830  2**2
                  ALLOC
  5 .comment      00000023  00000000  00000000  00001740  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000001a8  00000000  00000000  00001768  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000264  00000000  00000000  00001910  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00002da8  00000000  00000000  00001b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000acf  00000000  00000000  0000491c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00002242  00000000  00000000  000053eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000288  00000000  00000000  00007630  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000769  00000000  00000000  000078b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000004bd  00000000  00000000  00008021  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000010  00000000  00000000  000084e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000020  00000000  00000000  000084f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0000939a  2**0
                  CONTENTS, READONLY
 17 .cpu          0000000a  00000000  00000000  0000939d  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  000093a7  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  000093a8  2**0
                  CONTENTS, READONLY
 20 .stderr_dev   00000009  00000000  00000000  000093a9  2**0
                  CONTENTS, READONLY
 21 .stdin_dev    00000009  00000000  00000000  000093b2  2**0
                  CONTENTS, READONLY
 22 .stdout_dev   00000009  00000000  00000000  000093bb  2**0
                  CONTENTS, READONLY
 23 .sopc_system_name 00000008  00000000  00000000  000093c4  2**0
                  CONTENTS, READONLY
 24 .quartus_project_dir 00000040  00000000  00000000  000093cc  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     0002b582  00000000  00000000  0000940c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00010000 l    d  .entry	00000000 .entry
00010020 l    d  .text	00000000 .text
00010644 l    d  .rodata	00000000 .rodata
00010650 l    d  .rwdata	00000000 .rwdata
00010830 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00010058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00010650 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_load.c
0001037c l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_write.c
00010498 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
0001005c g     F .text	00000064 alt_main
00010104 g     F .text	00000090 _puts_r
00010740 g       *ABS*	00000000 __flash_rwdata_start
00010738 g     O .rwdata	00000004 jtag_uart
00000000  w      *UND*	00000000 __errno
00010000 g     F .entry	0000000c __reset
00010020 g       *ABS*	00000000 __flash_exceptions_start
00010830 g     O .bss	00000004 errno
00018730 g       *ABS*	00000000 _gp
00010194 g     F .text	00000014 puts
00010734 g     O .rwdata	00000004 _global_impure_ptr
00010834 g       *ABS*	00000000 __bss_end
000105ec g     F .text	0000001c alt_dcache_flush_all
00010740 g       *ABS*	00000000 __ram_rwdata_end
00010000 g       *ABS*	00000000 __alt_mem_onchip_memory
000103e8 g     F .text	000000b0 write
00010650 g       *ABS*	00000000 __ram_rodata_end
00010834 g       *ABS*	00000000 end
0001a000 g       *ABS*	00000000 __alt_stack_pointer
00010548 g     F .text	000000a4 altera_avalon_jtag_uart_write
00010020 g     F .text	0000003c _start
0001052c g     F .text	0000001c alt_sys_init
00010650 g       *ABS*	00000000 __ram_rwdata_start
00010644 g       *ABS*	00000000 __ram_rodata_start
00010834 g       *ABS*	00000000 __alt_stack_base
000101c8 g     F .text	000000bc __sfvwrite_small_dev
00010830 g       *ABS*	00000000 __bss_start
00000000         *UND*	00000000 main
0001073c g     O .rwdata	00000004 alt_errno
00010644 g       *ABS*	00000000 __flash_rodata_start
000100c0 g     F .text	00000044 delay
000104f8 g     F .text	00000034 alt_irq_init
00010284 g     F .text	00000078 _write_r
00010730 g     O .rwdata	00000004 _impure_ptr
00010020 g       *ABS*	00000000 __ram_exceptions_start
00010740 g       *ABS*	00000000 _edata
00010834 g       *ABS*	00000000 _end
00010020 g       *ABS*	00000000 __ram_exceptions_end
00010624 g     F .text	00000020 altera_nios2_qsys_irq_init
0001000c g       .entry	00000000 exit
0001a000 g       *ABS*	00000000 __alt_data_end
0001000c g       .entry	00000000 _exit
000101a8 g     F .text	00000020 strlen
00010608 g     F .text	0000001c alt_icache_flush_all
000102fc g     F .text	00000080 alt_load



Disassembly of section .entry:

00010000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   10000:	00400074 	movhi	at,1
    ori r1, r1, %lo(_start)
   10004:	08400814 	ori	at,at,32
    jmp r1
   10008:	0800683a 	jmp	at

0001000c <_exit>:
	...

Disassembly of section .text:

00010020 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   10020:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
   10024:	dee80014 	ori	sp,sp,40960

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
   10028:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
   1002c:	d6a1cc14 	ori	gp,gp,34608
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   10030:	00800074 	movhi	r2,1
    ori r2, r2, %lo(__bss_start)
   10034:	10820c14 	ori	r2,r2,2096

    movhi r3, %hi(__bss_end)
   10038:	00c00074 	movhi	r3,1
    ori r3, r3, %lo(__bss_end)
   1003c:	18c20d14 	ori	r3,r3,2100

    beq r2, r3, 1f
   10040:	10c00326 	beq	r2,r3,10050 <_start+0x30>

0:
    stw zero, (r2)
   10044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   10048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   1004c:	10fffd36 	bltu	r2,r3,10044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   10050:	00102fc0 	call	102fc <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   10054:	001005c0 	call	1005c <alt_main>

00010058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   10058:	003fff06 	br	10058 <alt_after_alt_main>

0001005c <alt_main>:
#include "system.h"
#include "altera_avalon_pio_regs.h"
#include <stdio.h>
void delay(void);
int alt_main(void)
{
   1005c:	defffc04 	addi	sp,sp,-16
   10060:	dfc00315 	stw	ra,12(sp)
   10064:	df000215 	stw	fp,8(sp)
   10068:	df000204 	addi	fp,sp,8
	unsigned int led_data;
	unsigned int led_code;
	printf("fpga\n");
   1006c:	01000074 	movhi	r4,1
   10070:	21019104 	addi	r4,r4,1604
   10074:	00101940 	call	10194 <puts>
	while(1)
	{
		for(led_data=0;led_data<18;led_data++)
   10078:	e03fff15 	stw	zero,-4(fp)
   1007c:	00000c06 	br	100b0 <alt_main+0x54>
		{
			led_code=0x01<<led_data;
   10080:	e0ffff17 	ldw	r3,-4(fp)
   10084:	00800044 	movi	r2,1
   10088:	10c4983a 	sll	r2,r2,r3
   1008c:	e0bffe15 	stw	r2,-8(fp)
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_18_BASE,led_code);
   10090:	e0fffe17 	ldw	r3,-8(fp)
   10094:	008000b4 	movhi	r2,2
   10098:	10840004 	addi	r2,r2,4096
   1009c:	10c00035 	stwio	r3,0(r2)
			delay();
   100a0:	00100c00 	call	100c0 <delay>
	unsigned int led_data;
	unsigned int led_code;
	printf("fpga\n");
	while(1)
	{
		for(led_data=0;led_data<18;led_data++)
   100a4:	e0bfff17 	ldw	r2,-4(fp)
   100a8:	10800044 	addi	r2,r2,1
   100ac:	e0bfff15 	stw	r2,-4(fp)
   100b0:	e0bfff17 	ldw	r2,-4(fp)
   100b4:	108004b0 	cmpltui	r2,r2,18
   100b8:	103ff11e 	bne	r2,zero,10080 <alt_main+0x24>
		{
			led_code=0x01<<led_data;
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_18_BASE,led_code);
			delay();
		}
	}
   100bc:	003fee06 	br	10078 <alt_main+0x1c>

000100c0 <delay>:
	return 0;
}

void delay(void)
{
   100c0:	defffe04 	addi	sp,sp,-8
   100c4:	df000115 	stw	fp,4(sp)
   100c8:	df000104 	addi	fp,sp,4
	unsigned int i;
	i=1000000;
   100cc:	008003f4 	movhi	r2,15
   100d0:	10909004 	addi	r2,r2,16960
   100d4:	e0bfff15 	stw	r2,-4(fp)
	while(i>0)
   100d8:	00000306 	br	100e8 <delay+0x28>
	{i--;}
   100dc:	e0bfff17 	ldw	r2,-4(fp)
   100e0:	10bfffc4 	addi	r2,r2,-1
   100e4:	e0bfff15 	stw	r2,-4(fp)

void delay(void)
{
	unsigned int i;
	i=1000000;
	while(i>0)
   100e8:	e0bfff17 	ldw	r2,-4(fp)
   100ec:	1004c03a 	cmpne	r2,r2,zero
   100f0:	103ffa1e 	bne	r2,zero,100dc <delay+0x1c>
	{i--;}
}
   100f4:	e037883a 	mov	sp,fp
   100f8:	df000017 	ldw	fp,0(sp)
   100fc:	dec00104 	addi	sp,sp,4
   10100:	f800283a 	ret

00010104 <_puts_r>:
   10104:	defffd04 	addi	sp,sp,-12
   10108:	dc000015 	stw	r16,0(sp)
   1010c:	2021883a 	mov	r16,r4
   10110:	2809883a 	mov	r4,r5
   10114:	dfc00215 	stw	ra,8(sp)
   10118:	dc400115 	stw	r17,4(sp)
   1011c:	2823883a 	mov	r17,r5
   10120:	00101a80 	call	101a8 <strlen>
   10124:	80c00217 	ldw	r3,8(r16)
   10128:	02000074 	movhi	r8,1
   1012c:	42007204 	addi	r8,r8,456
   10130:	880d883a 	mov	r6,r17
   10134:	100f883a 	mov	r7,r2
   10138:	8009883a 	mov	r4,r16
   1013c:	180b883a 	mov	r5,r3
   10140:	1a000115 	stw	r8,4(r3)
   10144:	403ee83a 	callr	r8
   10148:	047fffc4 	movi	r17,-1
   1014c:	8009883a 	mov	r4,r16
   10150:	01800074 	movhi	r6,1
   10154:	31819304 	addi	r6,r6,1612
   10158:	01c00044 	movi	r7,1
   1015c:	1440071e 	bne	r2,r17,1017c <_puts_r+0x78>
   10160:	00ffffc4 	movi	r3,-1
   10164:	1805883a 	mov	r2,r3
   10168:	dfc00217 	ldw	ra,8(sp)
   1016c:	dc400117 	ldw	r17,4(sp)
   10170:	dc000017 	ldw	r16,0(sp)
   10174:	dec00304 	addi	sp,sp,12
   10178:	f800283a 	ret
   1017c:	81400217 	ldw	r5,8(r16)
   10180:	28c00117 	ldw	r3,4(r5)
   10184:	183ee83a 	callr	r3
   10188:	0007883a 	mov	r3,zero
   1018c:	147ff51e 	bne	r2,r17,10164 <_puts_r+0x60>
   10190:	003ff306 	br	10160 <_puts_r+0x5c>

00010194 <puts>:
   10194:	00800074 	movhi	r2,1
   10198:	1081cc04 	addi	r2,r2,1840
   1019c:	200b883a 	mov	r5,r4
   101a0:	11000017 	ldw	r4,0(r2)
   101a4:	00101041 	jmpi	10104 <_puts_r>

000101a8 <strlen>:
   101a8:	20800007 	ldb	r2,0(r4)
   101ac:	10000526 	beq	r2,zero,101c4 <strlen+0x1c>
   101b0:	2007883a 	mov	r3,r4
   101b4:	18c00044 	addi	r3,r3,1
   101b8:	18800007 	ldb	r2,0(r3)
   101bc:	103ffd1e 	bne	r2,zero,101b4 <strlen+0xc>
   101c0:	1905c83a 	sub	r2,r3,r4
   101c4:	f800283a 	ret

000101c8 <__sfvwrite_small_dev>:
   101c8:	2880000b 	ldhu	r2,0(r5)
   101cc:	defffa04 	addi	sp,sp,-24
   101d0:	dcc00315 	stw	r19,12(sp)
   101d4:	1080020c 	andi	r2,r2,8
   101d8:	dc800215 	stw	r18,8(sp)
   101dc:	dc400115 	stw	r17,4(sp)
   101e0:	dfc00515 	stw	ra,20(sp)
   101e4:	dd000415 	stw	r20,16(sp)
   101e8:	dc000015 	stw	r16,0(sp)
   101ec:	2825883a 	mov	r18,r5
   101f0:	2027883a 	mov	r19,r4
   101f4:	3023883a 	mov	r17,r6
   101f8:	10002026 	beq	r2,zero,1027c <__sfvwrite_small_dev+0xb4>
   101fc:	2940008f 	ldh	r5,2(r5)
   10200:	28000f16 	blt	r5,zero,10240 <__sfvwrite_small_dev+0x78>
   10204:	01c01b0e 	bge	zero,r7,10274 <__sfvwrite_small_dev+0xac>
   10208:	3821883a 	mov	r16,r7
   1020c:	05010004 	movi	r20,1024
   10210:	00000206 	br	1021c <__sfvwrite_small_dev+0x54>
   10214:	0400170e 	bge	zero,r16,10274 <__sfvwrite_small_dev+0xac>
   10218:	9140008f 	ldh	r5,2(r18)
   1021c:	880d883a 	mov	r6,r17
   10220:	9809883a 	mov	r4,r19
   10224:	800f883a 	mov	r7,r16
   10228:	a400010e 	bge	r20,r16,10230 <__sfvwrite_small_dev+0x68>
   1022c:	01c10004 	movi	r7,1024
   10230:	00102840 	call	10284 <_write_r>
   10234:	88a3883a 	add	r17,r17,r2
   10238:	80a1c83a 	sub	r16,r16,r2
   1023c:	00bff516 	blt	zero,r2,10214 <__sfvwrite_small_dev+0x4c>
   10240:	9080000b 	ldhu	r2,0(r18)
   10244:	00ffffc4 	movi	r3,-1
   10248:	10801014 	ori	r2,r2,64
   1024c:	9080000d 	sth	r2,0(r18)
   10250:	1805883a 	mov	r2,r3
   10254:	dfc00517 	ldw	ra,20(sp)
   10258:	dd000417 	ldw	r20,16(sp)
   1025c:	dcc00317 	ldw	r19,12(sp)
   10260:	dc800217 	ldw	r18,8(sp)
   10264:	dc400117 	ldw	r17,4(sp)
   10268:	dc000017 	ldw	r16,0(sp)
   1026c:	dec00604 	addi	sp,sp,24
   10270:	f800283a 	ret
   10274:	0007883a 	mov	r3,zero
   10278:	003ff506 	br	10250 <__sfvwrite_small_dev+0x88>
   1027c:	00ffffc4 	movi	r3,-1
   10280:	003ff306 	br	10250 <__sfvwrite_small_dev+0x88>

00010284 <_write_r>:
   10284:	defffd04 	addi	sp,sp,-12
   10288:	dc000015 	stw	r16,0(sp)
   1028c:	04000074 	movhi	r16,1
   10290:	84020c04 	addi	r16,r16,2096
   10294:	dc400115 	stw	r17,4(sp)
   10298:	80000015 	stw	zero,0(r16)
   1029c:	2023883a 	mov	r17,r4
   102a0:	2809883a 	mov	r4,r5
   102a4:	300b883a 	mov	r5,r6
   102a8:	380d883a 	mov	r6,r7
   102ac:	dfc00215 	stw	ra,8(sp)
   102b0:	00103e80 	call	103e8 <write>
   102b4:	1007883a 	mov	r3,r2
   102b8:	00bfffc4 	movi	r2,-1
   102bc:	18800626 	beq	r3,r2,102d8 <_write_r+0x54>
   102c0:	1805883a 	mov	r2,r3
   102c4:	dfc00217 	ldw	ra,8(sp)
   102c8:	dc400117 	ldw	r17,4(sp)
   102cc:	dc000017 	ldw	r16,0(sp)
   102d0:	dec00304 	addi	sp,sp,12
   102d4:	f800283a 	ret
   102d8:	80800017 	ldw	r2,0(r16)
   102dc:	103ff826 	beq	r2,zero,102c0 <_write_r+0x3c>
   102e0:	88800015 	stw	r2,0(r17)
   102e4:	1805883a 	mov	r2,r3
   102e8:	dfc00217 	ldw	ra,8(sp)
   102ec:	dc400117 	ldw	r17,4(sp)
   102f0:	dc000017 	ldw	r16,0(sp)
   102f4:	dec00304 	addi	sp,sp,12
   102f8:	f800283a 	ret

000102fc <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   102fc:	defffe04 	addi	sp,sp,-8
   10300:	dfc00115 	stw	ra,4(sp)
   10304:	df000015 	stw	fp,0(sp)
   10308:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   1030c:	01000074 	movhi	r4,1
   10310:	2101d004 	addi	r4,r4,1856
   10314:	01400074 	movhi	r5,1
   10318:	29419404 	addi	r5,r5,1616
   1031c:	01800074 	movhi	r6,1
   10320:	3181d004 	addi	r6,r6,1856
   10324:	001037c0 	call	1037c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   10328:	01000074 	movhi	r4,1
   1032c:	21000804 	addi	r4,r4,32
   10330:	01400074 	movhi	r5,1
   10334:	29400804 	addi	r5,r5,32
   10338:	01800074 	movhi	r6,1
   1033c:	31800804 	addi	r6,r6,32
   10340:	001037c0 	call	1037c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   10344:	01000074 	movhi	r4,1
   10348:	21019104 	addi	r4,r4,1604
   1034c:	01400074 	movhi	r5,1
   10350:	29419104 	addi	r5,r5,1604
   10354:	01800074 	movhi	r6,1
   10358:	31819404 	addi	r6,r6,1616
   1035c:	001037c0 	call	1037c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   10360:	00105ec0 	call	105ec <alt_dcache_flush_all>
  alt_icache_flush_all();
   10364:	00106080 	call	10608 <alt_icache_flush_all>
}
   10368:	e037883a 	mov	sp,fp
   1036c:	dfc00117 	ldw	ra,4(sp)
   10370:	df000017 	ldw	fp,0(sp)
   10374:	dec00204 	addi	sp,sp,8
   10378:	f800283a 	ret

0001037c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   1037c:	defffc04 	addi	sp,sp,-16
   10380:	df000315 	stw	fp,12(sp)
   10384:	df000304 	addi	fp,sp,12
   10388:	e13ffd15 	stw	r4,-12(fp)
   1038c:	e17ffe15 	stw	r5,-8(fp)
   10390:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   10394:	e0fffe17 	ldw	r3,-8(fp)
   10398:	e0bffd17 	ldw	r2,-12(fp)
   1039c:	18800e26 	beq	r3,r2,103d8 <alt_load_section+0x5c>
  {
    while( to != end )
   103a0:	00000a06 	br	103cc <alt_load_section+0x50>
    {
      *to++ = *from++;
   103a4:	e0bffd17 	ldw	r2,-12(fp)
   103a8:	10c00017 	ldw	r3,0(r2)
   103ac:	e0bffe17 	ldw	r2,-8(fp)
   103b0:	10c00015 	stw	r3,0(r2)
   103b4:	e0bffe17 	ldw	r2,-8(fp)
   103b8:	10800104 	addi	r2,r2,4
   103bc:	e0bffe15 	stw	r2,-8(fp)
   103c0:	e0bffd17 	ldw	r2,-12(fp)
   103c4:	10800104 	addi	r2,r2,4
   103c8:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   103cc:	e0fffe17 	ldw	r3,-8(fp)
   103d0:	e0bfff17 	ldw	r2,-4(fp)
   103d4:	18bff31e 	bne	r3,r2,103a4 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
   103d8:	e037883a 	mov	sp,fp
   103dc:	df000017 	ldw	fp,0(sp)
   103e0:	dec00104 	addi	sp,sp,4
   103e4:	f800283a 	ret

000103e8 <write>:
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   103e8:	defff904 	addi	sp,sp,-28
   103ec:	dfc00615 	stw	ra,24(sp)
   103f0:	df000515 	stw	fp,20(sp)
   103f4:	df000504 	addi	fp,sp,20
   103f8:	e13ffb15 	stw	r4,-20(fp)
   103fc:	e17ffc15 	stw	r5,-16(fp)
   10400:	e1bffd15 	stw	r6,-12(fp)
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   10404:	e0bffb17 	ldw	r2,-20(fp)
   10408:	e0bfff15 	stw	r2,-4(fp)
   1040c:	e0ffff17 	ldw	r3,-4(fp)
   10410:	18800060 	cmpeqi	r2,r3,1
   10414:	1000041e 	bne	r2,zero,10428 <write+0x40>
   10418:	e0ffff17 	ldw	r3,-4(fp)
   1041c:	188000a0 	cmpeqi	r2,r3,2
   10420:	1000091e 	bne	r2,zero,10448 <write+0x60>
   10424:	00001006 	br	10468 <write+0x80>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   10428:	e17ffc17 	ldw	r5,-16(fp)
   1042c:	e1bffd17 	ldw	r6,-12(fp)
   10430:	01000074 	movhi	r4,1
   10434:	2101ce04 	addi	r4,r4,1848
   10438:	000f883a 	mov	r7,zero
   1043c:	00105480 	call	10548 <altera_avalon_jtag_uart_write>
   10440:	e0bffe15 	stw	r2,-8(fp)
   10444:	00000e06 	br	10480 <write+0x98>
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
   10448:	e17ffc17 	ldw	r5,-16(fp)
   1044c:	e1bffd17 	ldw	r6,-12(fp)
   10450:	01000074 	movhi	r4,1
   10454:	2101ce04 	addi	r4,r4,1848
   10458:	000f883a 	mov	r7,zero
   1045c:	00105480 	call	10548 <altera_avalon_jtag_uart_write>
   10460:	e0bffe15 	stw	r2,-8(fp)
   10464:	00000606 	br	10480 <write+0x98>
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   10468:	00104980 	call	10498 <alt_get_errno>
   1046c:	1007883a 	mov	r3,r2
   10470:	00801444 	movi	r2,81
   10474:	18800015 	stw	r2,0(r3)
        return -1;
   10478:	00bfffc4 	movi	r2,-1
   1047c:	e0bffe15 	stw	r2,-8(fp)
   10480:	e0bffe17 	ldw	r2,-8(fp)
    }
}
   10484:	e037883a 	mov	sp,fp
   10488:	dfc00117 	ldw	ra,4(sp)
   1048c:	df000017 	ldw	fp,0(sp)
   10490:	dec00204 	addi	sp,sp,8
   10494:	f800283a 	ret

00010498 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   10498:	defffd04 	addi	sp,sp,-12
   1049c:	dfc00215 	stw	ra,8(sp)
   104a0:	df000115 	stw	fp,4(sp)
   104a4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
   104a8:	00800074 	movhi	r2,1
   104ac:	1081cf04 	addi	r2,r2,1852
   104b0:	10800017 	ldw	r2,0(r2)
   104b4:	1005003a 	cmpeq	r2,r2,zero
   104b8:	1000061e 	bne	r2,zero,104d4 <alt_get_errno+0x3c>
   104bc:	00800074 	movhi	r2,1
   104c0:	1081cf04 	addi	r2,r2,1852
   104c4:	10800017 	ldw	r2,0(r2)
   104c8:	103ee83a 	callr	r2
   104cc:	e0bfff15 	stw	r2,-4(fp)
   104d0:	00000306 	br	104e0 <alt_get_errno+0x48>
   104d4:	00800074 	movhi	r2,1
   104d8:	10820c04 	addi	r2,r2,2096
   104dc:	e0bfff15 	stw	r2,-4(fp)
   104e0:	e0bfff17 	ldw	r2,-4(fp)
}
   104e4:	e037883a 	mov	sp,fp
   104e8:	dfc00117 	ldw	ra,4(sp)
   104ec:	df000017 	ldw	fp,0(sp)
   104f0:	dec00204 	addi	sp,sp,8
   104f4:	f800283a 	ret

000104f8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   104f8:	defffd04 	addi	sp,sp,-12
   104fc:	dfc00215 	stw	ra,8(sp)
   10500:	df000115 	stw	fp,4(sp)
   10504:	df000104 	addi	fp,sp,4
   10508:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS, nios2_qsys);
   1050c:	00106240 	call	10624 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   10510:	00800044 	movi	r2,1
   10514:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   10518:	e037883a 	mov	sp,fp
   1051c:	dfc00117 	ldw	ra,4(sp)
   10520:	df000017 	ldw	fp,0(sp)
   10524:	dec00204 	addi	sp,sp,8
   10528:	f800283a 	ret

0001052c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   1052c:	deffff04 	addi	sp,sp,-4
   10530:	df000015 	stw	fp,0(sp)
   10534:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
}
   10538:	e037883a 	mov	sp,fp
   1053c:	df000017 	ldw	fp,0(sp)
   10540:	dec00104 	addi	sp,sp,4
   10544:	f800283a 	ret

00010548 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   10548:	defff904 	addi	sp,sp,-28
   1054c:	df000615 	stw	fp,24(sp)
   10550:	df000604 	addi	fp,sp,24
   10554:	e13ffc15 	stw	r4,-16(fp)
   10558:	e17ffd15 	stw	r5,-12(fp)
   1055c:	e1bffe15 	stw	r6,-8(fp)
   10560:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
   10564:	e0bffc17 	ldw	r2,-16(fp)
   10568:	10800017 	ldw	r2,0(r2)
   1056c:	e0bffb15 	stw	r2,-20(fp)

  const char * end = ptr + count;
   10570:	e0bffe17 	ldw	r2,-8(fp)
   10574:	1007883a 	mov	r3,r2
   10578:	e0bffd17 	ldw	r2,-12(fp)
   1057c:	10c5883a 	add	r2,r2,r3
   10580:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
   10584:	00001106 	br	105cc <altera_avalon_jtag_uart_write+0x84>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   10588:	e0bffb17 	ldw	r2,-20(fp)
   1058c:	10800104 	addi	r2,r2,4
   10590:	10800037 	ldwio	r2,0(r2)
   10594:	10bfffec 	andhi	r2,r2,65535
   10598:	1005003a 	cmpeq	r2,r2,zero
   1059c:	10000b1e 	bne	r2,zero,105cc <altera_avalon_jtag_uart_write+0x84>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   105a0:	e13ffb17 	ldw	r4,-20(fp)
   105a4:	e0bffd17 	ldw	r2,-12(fp)
   105a8:	10800003 	ldbu	r2,0(r2)
   105ac:	10c03fcc 	andi	r3,r2,255
   105b0:	18c0201c 	xori	r3,r3,128
   105b4:	18ffe004 	addi	r3,r3,-128
   105b8:	e0bffd17 	ldw	r2,-12(fp)
   105bc:	10800044 	addi	r2,r2,1
   105c0:	e0bffd15 	stw	r2,-12(fp)
   105c4:	2005883a 	mov	r2,r4
   105c8:	10c00035 	stwio	r3,0(r2)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   105cc:	e0fffd17 	ldw	r3,-12(fp)
   105d0:	e0bffa17 	ldw	r2,-24(fp)
   105d4:	18bfec36 	bltu	r3,r2,10588 <altera_avalon_jtag_uart_write+0x40>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
   105d8:	e0bffe17 	ldw	r2,-8(fp)
}
   105dc:	e037883a 	mov	sp,fp
   105e0:	df000017 	ldw	fp,0(sp)
   105e4:	dec00104 	addi	sp,sp,4
   105e8:	f800283a 	ret

000105ec <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   105ec:	deffff04 	addi	sp,sp,-4
   105f0:	df000015 	stw	fp,0(sp)
   105f4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   105f8:	e037883a 	mov	sp,fp
   105fc:	df000017 	ldw	fp,0(sp)
   10600:	dec00104 	addi	sp,sp,4
   10604:	f800283a 	ret

00010608 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   10608:	deffff04 	addi	sp,sp,-4
   1060c:	df000015 	stw	fp,0(sp)
   10610:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   10614:	e037883a 	mov	sp,fp
   10618:	df000017 	ldw	fp,0(sp)
   1061c:	dec00104 	addi	sp,sp,4
   10620:	f800283a 	ret

00010624 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
   10624:	deffff04 	addi	sp,sp,-4
   10628:	df000015 	stw	fp,0(sp)
   1062c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   10630:	000170fa 	wrctl	ienable,zero
}
   10634:	e037883a 	mov	sp,fp
   10638:	df000017 	ldw	fp,0(sp)
   1063c:	dec00104 	addi	sp,sp,4
   10640:	f800283a 	ret
